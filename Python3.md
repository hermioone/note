# 第3章 Python的基本类型

## 3-2 数字：整型与浮点型

* 整数：int
* 浮点数：float
* 布尔：bool

> **注**：bool是Number类型

```type()```：可以判断类型

* ```type(1 * 1)```：```<class 'int'>```

* ```type(1 * 1.0)```：```<class 'float'>```

* ```type(2 / 2)```：```<class 'float'>```

* ```type(2 // 2)```：```<class 'int'>```

  ```2 / 2```：```1.0``` 

  ```1 // 2```：```0```

  ```int(True)```：```0```

## 3-4 各进制的表示与转换

表示：

* 二进制
  * ```0b10```：2
* 八进制
  * ```0o11```：9
* 十六进制
  * ```0x1F```：31

转换：

* 二进制
  * ```bin(10)```：```'0b1010'```
  * ```bin(0xE)```：```'0b1110'```
* 十进制
  * ```int(0b111)```：```7```
* 八进制
  * ```hex(0o7777)```：```'0xfff'```
* 十六进制
  * ```oct(0b111)```：```'0o7'```

##  3-6 字符串

可以用单引号、双引号、三引号表示字符串

![](http://static.zybuluo.com/vermouth9/xd0071olggreac1sy3zwtl6a/image.png)

## 3-9 原始字符串

```print(r'c:\northwind\northwest')```：字符串前面加r，不是一个普通字符串，而是原始字符串（按字符串的样式输出，不会把```\n```当作换行）。

## 3-10 字符串运算 一

字符串的运算

* 字符串合并
  * ```'hello' + 'world'```
  * ```'hello' * 3```：```'hellohellohello'```，只能和```int```相乘
* 字符串索引
  * ```'hello'[0]```
  * ```'hello world'[-1]```：```'d'```，[-n]从字符串的末尾往前数n个
* 字符串截取
  * ```'hello world'[0:4]```：```'hell'```，包前不包后
  * ```'hello wolrd'[0:-1]```：```'hello worl'```
  * ```'hello wolrd'[6:20]```：```'world'```
  * ```'hello world'[6:]```：```'world'```

# 第4章 Python中表示“组”的概念与定义

## 4-1 列表的定义

```type([1, 2, 3, 4])```：```<class 'list'>```

## 4-2 列表的基本操作

* 增
  * ```["新月打击", "苍白之瀑", "月之降临", "月神冲刺"] + ["点燃", "闪现"] ```：```["新月打击", "苍白之瀑", "月之降临", "月神冲刺", "点燃", "闪现"]```
  * ```["点燃", "闪现"] * 3 ```：```["点燃", "闪现", "点燃", "闪现", "点燃", "闪现"] ```
* 查
  * ```["新月打击", "苍白之瀑", "月之降临", "月神冲刺"][1]```：```"苍白之瀑"```
  * ```["新月打击", "苍白之瀑", "月之降临", "月神冲刺"][-1:]```：```["月神冲刺"]```
  * 和字符串的截取基本上一样

空的列表：

* ```type([])```：```<class 'list'>```
* ```type(list())```：```<class 'list'>```

## 4-3 元组

```type((1, 2, 3, 4))```：```<class 'tuple'>```

访问方式和列表及字符串一样

* ```(1, 2, 3) + (4, 5)```：```(1, 2, 3, ,4, 5)```
* ```(1, 2, 3) * 2```：```(1, 2, 3, 1, 2, 3)```
* ```type((1))```：```<class 'int'>```
  * 这因为```()```在python中既可以表示元组，也可以标识```(1 + 1)```这种运算，所以python硬性规定```()```中只有一个字符的话标识数序运算
* ```type((1,))```：```<class 'tuple'>```

***字符串、列表、元组都是序列***

序列的特点：

* 序号：```[1, 2, 3][2]```
* 切片：```'hello world'[0:2:]```

序列的操作：

* 包含：```3 in [1, 2, 3, 4]```，```'hello' in 'hello world'```
* 长度：```len([1, 2, 3, 4])```，```len('hello world')```
* 最大最小：```max([1, 2, 3, 5])```，```min([2, 1, 5])```，```max('hello world') == 'w'```，```min('hello world') == ' '```

空的元组：

- ```type(())```：```<class 'tuple'>```
- ```type(tuple())```：```<class 'tuple'>```

## 4-5 set集合

集合set特点：

* 无序
* 不能重复

```type({1, 2, 3})```：```<class 'set'>```

因为无序，所以集合不支持序号和切片

set的操作：

* 长度：```len({1, 2, 3})```
* 包含：```1 not in {1, 2, 3} == False```
* 两个集合的差集：```{1, 2, 3, 4, 5, 6} - {3, 4} == {1, 2, 5, 6}```
* 两个集合的交集：```{1, 2, 3, 4, 5, 6} & {3, 4} == {3, 4}```
* 两个集合的并集：```{1, 2, 3, 4, ,5, 6} | {3, 4, 7} == {1, 2, 3, ,4, 5, 6, 7}```

空的集合：

* ```type(set())```：```<class 'set'>```

## 4-6 dict字典

很多个key和value

```{'Q': '新月打击', 'W': '苍白之瀑', 'E': '月之降临', 'R': '月神冲刺'}```

字典中的value的范围：

* python中的任何字典

字典中的key的范围：

* 必须是不可变的类型：int，str，元组

空的字典：

* ```type({})```：```<class 'dict'>```
* ```type(dict())```：```<class 'dict'>```

## 4-7 基本数据类型总结

![](http://static.zybuluo.com/vermouth9/n488r3qcpqjb03w7e4vuqyew/image.png)

# 第5章 变量与运算符

## 5-1 什么是变量

```python
a, b = [1, 2, 3], [5, 6]
a * 2 + b + a		# [1, 2, 3, 1, 2, 3, 5, 6, 1, 2, 3]
```

## 5-3 值类型与引用类型

int：值类型

list：引用类型

```python
a = 1			# a指向1
b = a			# b指向1
a = 3			# a指向3，此时b还是指向1
print(b)		# 1

a = [1, 2, 3]	 # a指向[1, 2, 3]
b = a			# b指向[1, 2, 3]
a[0] = '1'		 # a指向的[1, 2, 3]中的第1位变成'1'，此时a的指向没有变，但是a指向的值发生了变化，所以b指向的值也会变化
print(b)		# ['1', 2, 3] 
```

***引用类型是可变的，但是值类型是不可变的***

值类型：不可变

* int
* str
* tuple

引用类型：可变

* list
* set
* dict

```python
a = 1
print(id(a))		# 1822974112
a = 2
print(id(a))		# 1822974144
a = [1, 2, 3]
print(hex(id(a))		# '0x241e207c608'
a[0] = '1'
print(hex(id(a))		# '0x241e207c608'

a = 'hello world'
a[0] = 'p'			# 报错，因为字符串是不可变类型
a = (1, 2, 3)
a[0] = '1'			# 报错
```

## 5-4 列表的可变与元组的不可变

```python
a = [1, 2, 3]
print(hex(id(a)))		 # '0x241e2076dc8'
a.append(4)
print(hex(id(a)))		 # '0x241e2076dc8'
print(a)				# [1, 2, 3, 4]
b = (1, 2, 3)
b.append(4)				# 报错

c = (1, 2, 3)
print(hex(id(c)))		# '0x241e2055d80'
c = c * 2
print(hex(id(c)))		# '0x241e1e2c228'

d = (1, 2, 3, [1, 2, 4])
d[3][2] = 5
print(d)				# (1, 2, 3, [1, 2, 5])

```

***注***：

* ```append()```方法是修改自身，不会创建新的
* ```c * 2```，```a + [4]```、```c + (123)是```创建新的

## 5-5  运算符号

![](http://static.zybuluo.com/vermouth9/bscxmt0s4yiupe7zwj5xy2im/image.png)

## 5-11 身份运算符

```python
a, b = 1, 1.0
print(a == b)			# True
print(a is b)			# False

a = {1, 2, 3}
b = {2, 1, 3}
print(a == b)			# True
print(a is b)			# False

c = (1, 2, 3)
d = (2, 1, 3)
print(c == d)			# False
print(c is d)			# False
```

```==```比较两个值是否相等，```is```比较的是两个变量的内存地址是否相等（```id(a) == id(b)```）

## 5-12 如何判断变量的值、身份与类型

对象的三个特征：

* 值
* 身份（地址）：```id()```
* 类型：```type()```，```isinstance(a, (str, float))```，```isinstance(a, str)```

判断对象类型推荐```isinstance()```，不推荐```type() == str```，因为```type```不能判断子类。

## 6-8 常量与Pylint的规范

### 1. 常量

* python中的常量并不是真的常量，因为python没有任何机制可以阻止修改常量的值。但是对于值不变的变量，规范的写法是全部大写。
* 变量应该位于函数或者类中，不要直接放在模块里，模块中应该是常量

```python
PI = 3.1415926
```

###  2. 模块

python每一个文件的开头需要写模块的注释

```python
'''
模块说明
'''
```

# 第7章 包、模块、函数与变量作用域

## 7-5 Python工程的组织结构

* 包
  * 模块
    * 类
      * 函数、变量

## 7-6 Python包与模块的名字

如果想让普通的文件夹变成包的话，文件夹下必须有一个```__init__.py```文件

```__init__py```这个模块的名字就是包名（文件夹名）

## 7-9 ```__init__.py```的用法

当导入包时，假设包名为a，```import a```会运行```__init__.py```的内容。

假设包a下有两个模块，c7.py和c8.py，在```__init__.py```中有```__all__ = ['c7']```，那么当通过*来导入这个包时：```from a import *```，只能导入c7这个模块，不能导入c8，但是可以如果```from a import c7, c8```则可以导入。

## 7-10 包与模块的几个常见错误

1. 包和模块时不会被重复导入的
2. 避免循环导入
3. 一旦导入一个模块，就会去执行模块里的代码

## 7-11 模块内置变量

```__xxx__```是python内置变量，但是从本质上来说和我们自己定义的变量没有什么区别。

```python
'''
this is __doc__
'''
a = 2
c = 3

infos = dir()
print(infos)
'''
['__annotations__', '__builtins__', '__cached__', 
'__doc__', '__file__', '__loader__', '__name__', '__package__', '__spec__', 'a', 'c']
'''
# __doc__：this is __doc__(模块注释)
```

## 7-12 入口文件和普通模块内置变量的区别

* c12.py
* t
  * c9.py

运行c12.py

```python
'''
c9 doc
'''

print("name: " + __name__)          # 命名
print("package: " + __package__)
print("doc: " + __doc__)            # 模块注释
print("file: " + __file__)
```

```python
'''
c12 doc
'''
import t.c9
'''
name: t.c9
package: t		相对于入口文件的包路径
doc:
c9 doc

file: E:\workspace\vscode-workspace\imooc\Python3入门进阶\chapter7\t\c9.py
'''

print('package: ' + (__package__ or '当前模块不属于任何包'))	# 入口文件没有顶级包
print('name: ' + __name__)          # name: __main__    因为c12此时是入口文件
print('doc: ' + __doc__)            # c12 doc
print('file: ' + __file__)          # file: .\c12.py    因为c12此时是入口文件
# __file__的取值和我们运行python命令的所在目录有关，因为是在c12.py所在目录中运行的，所以此时__file__ = .\c12.py
```

## 7-13```__name__```的经典应用

```python
import sys

infos = dir(sys)        # 当要查看某个模块或者某个类下面的变量的时候，就可以使用dir()，这里查看sys模块中的变量
print(infos)
```

```shell
python -m seven.c15
```

这样可以让c15.py当作模块来运行（前提是c15这个模块必须有个包，且在包外执行这条命令）

## 7-14 相对导入和绝对导入

顶级包：入口文件的同级目录为顶级包

* main.py
* package1
  * pakage11
    * m1.py

如上，顶级包为package1

绝对路径：从顶级包开始，

相对路径：.表示当前目录，..表示上级目录，...表示上级上级目录

***注：不能在入口文件中使用相对导入，只能使用绝对导入***

> 相对导入之所以能找到模块是因为从```__name__```来找，但是因为入口文件的```__name__ == __main__```，所以入口文件中不能使用相对导入









