# Docker + Kubernetes微服务容器化实践

## 第1章 初始微服务

### 1-2 软件架构的进化

**什么是单体架构？**

定义：功能、业务集中在一个发布包里，部署运行在同一个进程中。

**单体架构的优势？**

* 易于开发
* 易于测试
* 易于部署
* 易于水平伸缩。

**单体架构面临的挑战？**

* 代码膨胀，难以维护
* 构建、部署成本大
* 新人上手困难
* 创新困难
* 可扩展性差

### 1-3 什么是微服务

使用一套小服务来开发单个应用的方式，每个服务运行在**独立的进程**里，一般采用**轻量级的通讯**机制互联，并且它们可以通过**自动化**的方式部署。

**微服务的特征：**

* 单一职责
* 轻量级通信（和语言无关，比如HTTP）
* 隔离性
* 有自己的数据
* 技术多样性

> 器技术的成熟使得微服务落地成为可能。

传统的单体应用部署在web服务器中，微服务部署在容器中。

![](http://static.zybuluo.com/vermouth9/hgpep6bpv2tamngq9yvv69tq/%E6%8D%95%E8%8E%B7.PNG)

## 第2章 微服务带来的问题及解决方案分析

### 2-2 微服务间如何通讯

#### 从通讯模式角度考虑

* 一对一还是一对多
* 同步还是异步

|      | 一对一               | 一对多                  |
| ---- | -------------------- | ----------------------- |
| 同步 | 请求响应模式，最常见 |                         |
| 异步 | 通知 / 请求异步响应  | 发布订阅 / 发布异步响应 |

#### 从通讯协议角度考虑

* REST API
* RPC：dubbo，dubbox，thrift，grpc...
* MQ

#### 如何选择RPC框架

* I/O、线程调度模型
* 序列化方式：序列化的效率直接影响了RPC通信的效率
* 多语言支持
* 服务治理

#### 流行的RPC框架

* Dubbo

  实线表示同步调用，虚线表示异步调用。

  消费者和提供者之间通过NIO通信，序列化使用阿里修改过的Hessian序列化。

  ![](http://static.zybuluo.com/vermouth9/j3s1tl0u4trbp1pf9rtwn00e/image.png)

* Thrift

  支持多种序列化：二进制，压缩，json

  ![](http://static.zybuluo.com/vermouth9/r49lqihuy4hz3p0ex08auzu4/image.png)

  多种RPC框架对比

  ![](http://static.zybuluo.com/vermouth9/fefhymw8mpgh7kozo742g826/image.png)

### 2-3 服务发现、部署更新和扩容

#### 服务发现

**传统服务**

![](http://static.zybuluo.com/vermouth9/76d0zztgaif4xk9p86xt9gyc/image.png)

在Nginx把所有服务提供者都写死了。

**微服务的服务发现**

* 客户端发现

  微服务把自己注册到注册中心上，**客户端查询注册中心所注册的服务**，得到微服务提供者所注册的ip和端口号，然后通过本地的负载均衡策略对微服务进行访问。

* 服务端发现

  微服务把自己注册到注册中心上，**客户端访问一个具有服务发现和负载均衡功能的服务**，再由它将强求转发给后端的具体服务并且将应答回传给客户端。

#### 服务部署

**传统服务**

通过jenkins自动化部署

**微服务**

服务编排

## 第3章 微服务开发

### 3-1 微服务业务分析

![](http://static.zybuluo.com/vermouth9/vapoih4wak4c3x8l3ackjrsg/%E6%9E%B6%E6%9E%84%E5%9B%BE.png)











