# 0玩转数据结构 从入门到进阶

## c6 二分搜索树

### 6-2 二分搜索树基础

**二分搜索树的性质**：

* 二分搜索树是二叉树
* 二分搜索树的每个节点的值大于其左子树的所有节点的值，小于其右子树的所有节点的值

### 6-12 删除二分搜索树的任意元素

* 如果一个节点没有左子树，则可以删除以该节点为根的树的最小元素（即只要把该节点的右子树放在该节点位置即可）
* 如果一个节点没有右子树，则可以删除以该节点为根的树的最大元素（即只要把该节点的左子树放在该节点位置即可）
* 如果一个节点既有左子树也有右子树，Hibbard Deletion：可以把左子树的最大元素（或者右子树的最小元素）替换到该节点的位置。

## c7 集合和映射

### 7-8 映射的复杂度分析和更多映射相关的问题

|             | LinkedListMap | BSTMap 平均 | BSTMap 最差 |
| ----------- | ------------- | ----------- | ----------- |
| 增 add      | O(n)          | O(logn)     | O(n)        |
| 删 delete   | O(n)          | O(logn)     | O(n)        |
| 改 set      | O(n)          | O(logn)     | O(n)        |
| 查 get      | O(n)          | O(logn)     | O(n)        |
| 查 contains | O(n)          | O(logn)     | O(n)        |

LinkedListMap在做增删改查操作时，都需要先查询一个Map中是否含有key，所以时间复杂度也是O(n)。

因为二分搜索树最差情况下有可能沦为一个链表，这时二分搜索树时间复杂度也会很大，这是二分搜索树的一个最致命问题。所以后序会引入平衡二叉树。

映射：

* 有序映射：键具有顺序性    <== 基于搜索树的实现：TreeMap和TreeSet基于平衡二叉树（或者红黑树）实现
* 无序映射：键没有顺序性    <== 基于哈希表的实现：HashSet和HashMap基于哈希表实现

## c8 优先队列和堆

### 8-1 什么是优先队列

* 普通队列：先进先出，后进后出
* 优先队列：出队顺序和入队顺序无关；和优先级相关

**关键词**：动态

|                                                  | 入队    | 出队（拿出最大元素） |
| ------------------------------------------------ | ------- | -------------------- |
| 普通线性结构：出队先扫描找出最大值，把最大值出队 | O(1)    | O(n)                 |
| 顺序线性结构：入队按照大小顺序排列入队           | O(n)    | O(1)                 |
| 堆                                               | O(logn) | O(logn)              |

### 8-2 堆的基础表示

 堆最为主流的一种实现方式：**二叉堆**

**二叉堆的性质**：

* 二叉堆是一颗完全二叉树
  * 完全二叉树：不一定是满二叉树（除了叶子节点，其他节点的左右子数都不为空），但是缺失的部分一定是在二叉树的右侧。
* 最大堆：二叉堆中某个节点的值总是不大于其父节点的值（根节点的元素是最大的）。
* 最小堆：二叉堆中某个节点的值总是不小于其父节点的值（根节点的元素是最小的）。

注意：最大堆的低层级的节点值不一定就大于高层级的节点值。

![](http://static.zybuluo.com/vermouth9/7v0n32j4m06495y92tmkie0n/image.png)

例如位于2层的16和3层的19。

因为完全二叉树可以看作一层一层地从左向右码上去，所以可以把完全二叉树用数组来存储。

| 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 62   | 41   | 30   | 28   | 16   | 22   | 13   | 19   | 17   | 15   |

此时对于节点 i（节点在数组中的索引是 i）：
$$
parent(i) = (i - 1) / 2
$$

$$
left child = 2 * i + 1
$$

$$
right child = 2 * i + 2
$$

### 8-3 向堆中添加元素和Sift Up

1. 现在index 10添加元素52
2. 因为52的父节点 16小于 52，所以把52和16换一下位置，即把索引4变为52，索引10变为16
3. 此时52依然大于父节点41，所以把52和41再交换位置
4. 此时满足堆的性质。

### 8-4 从堆中取出元素和Sift Down

1. 取出堆的根节点
2. 把堆数组的最后一个元素挪到根节点
3. 把根节点元素和子元素的最大值比较，如果小，则交换位置，依次进行下去，直到满足堆特性。

