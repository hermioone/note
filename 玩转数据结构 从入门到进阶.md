# 0玩转数据结构 从入门到进阶

## C6 二分搜索树

### 6-2 二分搜索树基础

**二分搜索树的性质**：

* 二分搜索树是二叉树
* 二分搜索树的每个节点的值大于其左子树的所有节点的值，小于其右子树的所有节点的值

### 6-12 删除二分搜索树的任意元素

* 如果一个节点没有左子树，则可以删除以该节点为根的树的最小元素（即只要把该节点的右子树放在该节点位置即可）
* 如果一个节点没有右子树，则可以删除以该节点为根的树的最大元素（即只要把该节点的左子树放在该节点位置即可）
* 如果一个节点既有左子树也有右子树，Hibbard Deletion：可以把左子树的最大元素（或者右子树的最小元素）替换到该节点的位置。

## C7 集合和映射

### 7-8 映射的复杂度分析和更多映射相关的问题

|             | LinkedListMap | BSTMap 平均 | BSTMap 最差 |
| ----------- | ------------- | ----------- | ----------- |
| 增 add      | O(n)          | O(logn)     | O(n)        |
| 删 delete   | O(n)          | O(logn)     | O(n)        |
| 改 set      | O(n)          | O(logn)     | O(n)        |
| 查 get      | O(n)          | O(logn)     | O(n)        |
| 查 contains | O(n)          | O(logn)     | O(n)        |

LinkedListMap在做增删改查操作时，都需要先查询一个Map中是否含有key，所以时间复杂度也是O(n)。

因为二分搜索树最差情况下有可能沦为一个链表，这时二分搜索树时间复杂度也会很大，这是二分搜索树的一个最致命问题。所以后序会引入平衡二叉树。

映射：

* 有序映射：键具有顺序性    <== 基于搜索树的实现：TreeMap和TreeSet基于平衡二叉树（或者红黑树）实现
* 无序映射：键没有顺序性    <== 基于哈希表的实现：HashSet和HashMap基于哈希表实现

## C8 优先队列和堆

### 8-1 什么是优先队列

* 普通队列：先进先出，后进后出
* 优先队列：出队顺序和入队顺序无关；和优先级相关

**关键词**：动态

|                                                  | 入队    | 出队（拿出最大元素） |
| ------------------------------------------------ | ------- | -------------------- |
| 普通线性结构：出队先扫描找出最大值，把最大值出队 | O(1)    | O(n)                 |
| 顺序线性结构：入队按照大小顺序排列入队           | O(n)    | O(1)                 |
| 堆                                               | O(logn) | O(logn)              |

### 8-2 堆的基础表示

 堆最为主流的一种实现方式：**二叉堆**

**二叉堆的性质**：

* 二叉堆是一颗完全二叉树
  * 完全二叉树：不一定是满二叉树（除了叶子节点，其他节点的左右子数都不为空），但是缺失的部分一定是在二叉树的右侧。
* 最大堆：二叉堆中某个节点的值总是不大于其父节点的值（根节点的元素是最大的）。
* 最小堆：二叉堆中某个节点的值总是不小于其父节点的值（根节点的元素是最小的）。

注意：最大堆的低层级的节点值不一定就大于高层级的节点值。

![](http://static.zybuluo.com/vermouth9/7v0n32j4m06495y92tmkie0n/image.png)

例如位于2层的16和3层的19。

因为完全二叉树可以看作一层一层地从左向右码上去，所以可以把完全二叉树用数组来存储。

| 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 62   | 41   | 30   | 28   | 16   | 22   | 13   | 19   | 17   | 15   |

此时对于节点 i（节点在数组中的索引是 i）：
$$
parent(i) = (i - 1) / 2
$$

$$
left child = 2 * i + 1
$$

$$
right child = 2 * i + 2
$$

### 8-3 向堆中添加元素和Sift Up

1. 先在index 10添加元素52
2. 因为52的父节点 16小于 52，所以把52和16换一下位置，即把索引4变为52，索引10变为16
3. 此时52依然大于父节点41，所以把52和41再交换位置
4. 此时满足堆的性质。

### 8-4 从堆中取出元素和Sift Down

1. 取出堆的根节点
2. 把堆数组的最后一个元素挪到根节点
3. 把根节点元素和子元素的最大值比较，如果小，则交换位置，依次进行下去，直到满足堆特性。

### 8-5 Heapify和Replace

* Replace：取出堆中最大元素，再向堆中添加一个元素

  可以直接用新添加的元素替换堆顶元素，再执行Sift Down即可

* heapify：将任意数组整理成堆的形状

  把数组看作一个完全二叉树，从最后一个非叶子节点i开始，从索引i到0不断进行Sift Down操作，直到满足堆性质。

**计算最后一个非叶子节点的索引**：直接根据最后一个节点的索引，计算其父节点，也就是最后一个非叶子节点。

* 将n个元素逐个插入到一个空堆中，算法复杂度是O(logn)，因为对每个元素都要执行O(logn)级别的插入操作，总共有n个元素。
* heapify的过程，算法复杂度是O(n)。

```java
public class MaxHeap<E extends Comparable<E>> {

    private List<E> data;

    public MaxHeap(int capacity) {
        data = new ArrayList<>(capacity);
    }

    public MaxHeap() {
        data = new ArrayList<>();
    }

    /**
     * heapify
     * @param arr 任意元素
     */
    public MaxHeap(E[] arr) {
        data = new ArrayList<>(Arrays.asList(arr));
        for (int i = parent(arr.length - 1); i >= 0; i--) {
            siftDown(i);
        }
    }

    public int size() {
        return data.size();
    }

    public boolean isEmpty() {
        return data.isEmpty();
    }

    // 返回完全二叉树的数组表示中，一个索引所表示的元素的父节点的索引
    private int parent(int index) {
        if (index == 0) {
            throw new IllegalArgumentException("index-0木有父节点");
        }
        return (index - 1) / 2;
    }

    // 返回完全二叉树的数组表示中，一个索引所表示的元素的左孩子节点的索引
    private int leftChild(int index) {
        return index * 2 + 1;
    }

    // 返回完全二叉树的数组表示中，一个索引所表示的元素的右孩子节点的索引
    private int rightChild(int index) {
        return index * 2 + 2;
    }

    // 向堆中添加元素
    public void add(E e) {
        data.add(e);
        siftUp(data.size() - 1);
    }

    //查看堆的最大值
    public E findMax() {
        if (data.size() == 0) throw new IllegalArgumentException("堆是空的");
        return data.get(0);
    }

    // 从堆中取出最大元素
    public E extractMax() {
        E result = findMax();
        data.set(0, data.get(data.size() - 1));
        data.remove(data.size() - 1);
        siftDown(0);
        return result;
    }

    // 取出堆中最大元素，并且替换成元素e
    public E replace(E e) {
        E ret = findMax();
        data.set(0, e);
        siftDown(0);
        return ret;
    }

    private void siftDown(int k) {
        while (leftChild(k) < data.size()) {
            int i = leftChild(k);
            if (i + 1 < data.size() && data.get(i + 1).compareTo(data.get(i)) > 0) {
                i = rightChild(k);
            }
            //此时data.get(i)是左右两个子节点的最大值
            if (data.get(i).compareTo(data.get(k)) <= 0)
                break;
            E tmp = data.get(i);
            data.set(i, data.get(k));
            data.set(k, tmp);
            k = i;
        }
    }

    private void siftUp(int index) {
        for (; index > 0 && data.get(parent(index)).compareTo(data.get(index)) < 0;) {
            E tmp = data.get(parent(index));
            data.set(parent(index), data.get(index));
            data.set(index, tmp);
            index = parent(index);
        }
    }
}
```

### 8-7 Leetcode上优先队列相关问题

在1,000,000个元素中选出前100名？

在N个元素中选出前M个元素：

* 排序 ==> O(NlogN)
* 优先队列 ==> O(NlogM)

使用优先队列，维护当前看到的前M个元素，遇见一个新的元素，把它和队列中最小的元素比，如果比最小的大，则把最小的元素替换成当前元素，并执行相应操作满足二叉堆的性质。

这里需要使用***最小堆***。或者使用最大堆，但是规定频率越小优先级越高。

> 注：最大堆和最小堆的大和小都是相对的，可以根据需要定义不同的大和小的概念。

### 8-8 Java中的PriorityQueue

Java中的PriorityQueue内部是最小堆。

### 8-9 和堆相关的更多话题和广义队列

**这里实现的堆有一个明显的缺点**：只能看见堆首的元素，不能看见堆中的元素。

索引堆：可以解决这个问题，还可以修改堆中的元素。

##  C9 线段树

### 9-1 什么是线段树

线段树、区间树、Segment Tree

1. 为什么要使用线段树？

   * 有一类问题，我们关心的是线段（或者区间）

   * 最经典的线段树问题：区间染色

     有一面墙，长度为n，每次选择一段墙进行染色（可以覆盖之前已经染过色的区间），m次操作后，我们可以在[i, j]区间内看见多少种颜色？

     |                      | 使用数组实现 |
     | -------------------- | :----------: |
     | 染色操作（更新区间） |     O(n)     |
     | 查询操作（查询区间） |     O(n)     |

   * 另一类经典问题：区间查询

     查询一个区间[i, j]的最大值，最小值，或者区间数字和

     2017年注册用户中消费最高的用户？消费最小的用户？学习时间最长的用户？数据是动态的，因为用户在不断地进行消费，2017年注册的用户2018年也在接着消费，数据在持续不停地更新的同时进行查询。

     |      | 使用数组实现 | 使用线段树 |
     | ---- | :----------: | :--------: |
     | 更新 |     O(n)     |  O(logn)   |
     | 查询 |     O(n)     |  O(logn)   |

     对于给定区间

     更新：更新区间中一个元素或者一个区间的值

     查询：查询一个区间的最大值，最小值，或者区间数字和

2. 什么是线段树

   ![](http://static.zybuluo.com/vermouth9/j4ovyf1g4ep0osmbucb9hfmw/image.png)

   以求和为例：根节点存储的是整个区间的和，A[0...3]存储的是0-3这个区间的和，A[4...7]存储的是4-7这个区间的和。如果要求3-5这个区间的和，那么只需把A[3]和A[4...5]这两个节点加起来就行。

### 9-2 线段树基础表示

![](http://static.zybuluo.com/vermouth9/0tzdntcdrk3z6mgj8o1u74ge/image.png)

线段树不一定是完全二叉树，线段树是平衡二叉树

***平衡二叉树***：对于整棵树来说，最大的深度和最小的深度相差不能超过1。

完全二叉树一定是平衡二叉树，所以堆也是平衡二叉树。

二分搜索树不一定是平衡二叉树。

线段树也可以用数组来表示，可以把它看作是完全二叉树，缺失的部分都是null。

**如果区间有n个元素，数组表示需要有多少个节点？**

对满二叉树：h层，一共有2^h - 1个节点（约2 ^ h），最后一层（h-1层），有2 ^ (h-1)个节点，所以最后一层地节点数大致等于前面所有层节点之和。

如果区间有n个元素：

![](http://static.zybuluo.com/vermouth9/glpxjkcc44p37l20scdcyxys/image.png)

我们的线段树不考虑添加元素，即区间固定，使用4n的静态空间即可。

例如区间里有5个元素：

![](http://static.zybuluo.com/vermouth9/kjlxn4da6ei5bz9cfavb0xwf/image.png)

```java
public class SegmentTree<E> {
    private E[] tree;
    private E[] data;
    private Merger<E> merger;

    public SegmentTree(E[] arr, Merger<E> merger) {
        data = (E[])new Object[arr.length];
        for (int i = 0; i < arr.length; i++) {
            data[i] = arr[i];
        }
        this.merger = merger;
        tree = (E[])new Object[arr.length * 4];
        buildSegmentTree(0, 0, data.length - 1);
    }

    /**
     * 在treeIndex的位置创建表示区间[l...r]的线段树
     * @param treeIndex 当前索引
     * @param s 区间起始位置
     * @param e 区间结束位置
     */
    private void buildSegmentTree(int treeIndex, int s, int e) {
        if (s == e) {
            tree[treeIndex] = data[s];
            return;
        }
        int leftTreeIndex = leftChild(treeIndex);
        int rightTreeIndex = rightChild(treeIndex);
        int mid = s + (e - s) / 2;          // 防止s + e太大溢出
        buildSegmentTree(leftTreeIndex, s, mid);
        buildSegmentTree(rightTreeIndex, mid + 1, e);

        tree[treeIndex] = merger.merge(tree[leftTreeIndex], tree[rightTreeIndex]);           // 这个是和业务逻辑相关的
    }

    public int getSize() {
        return data.length;
    }

    public E get(int index) {
        if (index < 0 || index >= data.length)
            throw new IllegalArgumentException("索引不合法");
        return data[index];
    }

    // 返回一个完全二叉树的数组表示中，一个索引所表示的元素的左孩子节点的索引
    private int leftChild(int index) {
        return index * 2 + 1;
    }

    // 返回一个完全二叉树的数组表示中，一个索引所表示的元素的右孩子节点的索引
    private int rightChild(int index) {
        return index * 2 + 2;
    }

    /**
     * 线段树的查询，返回区间[start, end]的值
     * @param queryS 起始索引
     * @param queryE 结束索引
     * @return 区间[start, end]的值
     */
    public E query(int queryS, int queryE) {
        if (queryS < 0 || queryE < 0 || queryS > data.length || queryE > data.length || queryS > queryE)
            throw new IllegalArgumentException("参数不合法");
        return query(0, queryS, queryE, 0, data.length - 1);
    }

    /**
     * 把data的dataIndex位置的值更新为e
     * @param dataIndex
     * @param e
     */
    public void set(int dataIndex, E e) {
        if (dataIndex < 0 || dataIndex > data.length)
            throw new IllegalArgumentException("参数不合法");
        data[dataIndex] = e;
        set(0, 0, data.length - 1, dataIndex, e);
    }

    private void set(int treeIndex, int start, int end, int dataIndex, E e) {
        if (start == end) {
            tree[treeIndex] = e;
            return;
        }
        int leftChild = leftChild(treeIndex);
        int rightChild = rightChild(treeIndex);
        int mid = start + (end - start) / 2;
        if (dataIndex >= mid + 1)
            set(rightChild, mid + 1, end, dataIndex, e);            //更新右子树
        else
            set(leftChild, start, mid, dataIndex, e);                    //更新左子树
        tree[treeIndex] = merger.merge(tree[leftChild], tree[rightChild]);      //根据右子树和左子树来更新当前节点
    }


    private E query(int treeIndex, int queryS, int queryE, int start, int end) {
        if (queryS == start && queryE == end)
            return tree[treeIndex];
        int mid = start + (end - start) / 2;
        int leftTreeIndex = leftChild(treeIndex);
        int rightTreeIndex = rightChild(treeIndex);
        if (queryS >= mid + 1) {
            return query(rightTreeIndex, queryS, queryE, mid + 1, end);
        }else if (queryE <= mid) {
            return query(leftTreeIndex, queryS, queryE, start, mid);
        }else {
            E leftResult = query(leftTreeIndex, queryS, mid, start, mid);
            E rightResult = query(rightTreeIndex, mid + 1, queryE, mid + 1, end);
            return merger.merge(leftResult, rightResult);
        }
    }

    @Override
    public String toString() {
        StringBuilder res = new StringBuilder();
        res.append('[');
        for (int i = 0; i < tree.length; i++) {
            if (tree[i] != null)
                res.append(tree[i]);
            else
                res.append("null");
            if (i != tree.length - 1)
                res.append(", ");
        }
        res.append(']');
        return res.toString();
    }
}


interface Merger<E> {
    E merge(E a, E b);
}
```

### 9-7 更多线段树相关的话题

将区间中所有元素更新：O(n)的复杂度，为了解决这个问题，可以用懒惰更新。

对于区间操作还有一个重要的数据结构：树状数组（Binary Index Tree）

## C10 Trie 字典树

1. 什么是字典树（前缀树，Trie）

   Trie只用来处理字符串

   | 字典                                                         | Trie                                                         |
   | ------------------------------------------------------------ | ------------------------------------------------------------ |
   | 如果有n个条目，使用树结构，查询的时间复杂度是O(logn)，如果有100万个条目（2^20），logn大约为20 | 查询每个条目的时间复杂度和字典中一共有多少条目无关，时间复杂度为O(w)，w为查询单词的长度 |

   ![](http://static.zybuluo.com/vermouth9/u4yewg9lqsqyqyjwgbo8k1nw/image.png)

   上图中每一条都是一个单词，如图所示，查找一个单词只和单词的长度相关。

   每个节点有若干个指向下个节点的指针。

   ```java
   class Node {
       boolean isWord;    
       Map<Character, Node> next;
   }
   ```

 ```java
public class Trie {

    private class Node {
        public boolean isWord;			//当前节点是否是一个单词的结尾
        public TreeMap<Character, Node> next;
        public Node(boolean isWord) {
            this.isWord = isWord;		
            next = new TreeMap<>();
        }
        public Node() {
            this(false);
        }
    }

    private Node root;
    private int size;   //存储了多少单词

    public Trie() {
        root = new Node();
        size = 0;
    }

    //获得Trie中存储的单词数量
    public int getSize() {
        return size;
    }

    public void add(String word) {
        Node cur = root;
        for (int i = 0; i < word.length(); i++) {
            char c = word.charAt(i);
            if (cur.next.get(c) == null) {
                cur.next.put(c, new Node());
            }
            cur = cur.next.get(c);
        }
        if (!cur.isWord) {
            cur.isWord = true;
            size++;
        }
    }

    /**
     * 查询单词word是否在Trie中
     * @param word 要查询的单词
     * @return 单词是否在Trie中
     */
    public boolean contains(String word) {
        Node cur = root;
        for (int i = 0; i < word.length(); i++) {
            char c = word.charAt(i);
            if (cur.next.get(c) == null) {
                return false;
            }
            cur = cur.next.get(c);
        }
        return cur.isWord;
    }

    /**
     * 查询是否有以prefix为前缀的单词
     * @param prefix 前缀
     * @return
     */
    public boolean startWith(String prefix) {
        Node cur = root;
        for (int i = 0; i < prefix.length(); i++) {
            char c = prefix.charAt(i);
            if (cur.next.get(c) == null) {
                return false;
            }
            cur = cur.next.get(c);
        }
        return true;
    }
}
 ```

### 10-7 更多和Trie字典树相关的话题

Trie最大的问题：空间

## C11 并查集

一种由孩子指向父亲的树结构，可以解答图中的两点之间是否连同，非常快得判断网络中节点间的连接状态。也是数学中的集合类的实现。

对于一组数据，主要支持两个动作：

* union(p, q)
* isConnected(p, q)











