# 0玩转数据结构 从入门到进阶

## C6 二分搜索树

### 6-2 二分搜索树基础

**二分搜索树的性质**：

* 二分搜索树是二叉树
* 二分搜索树的每个节点的值大于其左子树的所有节点的值，小于其右子树的所有节点的值

### 6-12 删除二分搜索树的任意元素

* 如果一个节点没有左子树，则可以删除以该节点为根的树的最小元素（即只要把该节点的右子树放在该节点位置即可）
* 如果一个节点没有右子树，则可以删除以该节点为根的树的最大元素（即只要把该节点的左子树放在该节点位置即可）
* 如果一个节点既有左子树也有右子树，Hibbard Deletion：可以把左子树的最大元素（或者右子树的最小元素）替换到该节点的位置。

## C7 集合和映射

### 7-8 映射的复杂度分析和更多映射相关的问题

|             | LinkedListMap | BSTMap 平均 | BSTMap 最差 |
| ----------- | ------------- | ----------- | ----------- |
| 增 add      | O(n)          | O(logn)     | O(n)        |
| 删 delete   | O(n)          | O(logn)     | O(n)        |
| 改 set      | O(n)          | O(logn)     | O(n)        |
| 查 get      | O(n)          | O(logn)     | O(n)        |
| 查 contains | O(n)          | O(logn)     | O(n)        |

LinkedListMap在做增删改查操作时，都需要先查询一个Map中是否含有key，所以时间复杂度也是O(n)。

因为二分搜索树最差情况下有可能沦为一个链表，这时二分搜索树时间复杂度也会很大，这是二分搜索树的一个最致命问题。所以后序会引入平衡二叉树。

映射：

* 有序映射：键具有顺序性    <== 基于搜索树的实现：TreeMap和TreeSet基于平衡二叉树（或者红黑树）实现
* 无序映射：键没有顺序性    <== 基于哈希表的实现：HashSet和HashMap基于哈希表实现

## C8 优先队列和堆

### 8-1 什么是优先队列

* 普通队列：先进先出，后进后出
* 优先队列：出队顺序和入队顺序无关；和优先级相关

**关键词**：动态

|                                                  | 入队    | 出队（拿出最大元素） |
| ------------------------------------------------ | ------- | -------------------- |
| 普通线性结构：出队先扫描找出最大值，把最大值出队 | O(1)    | O(n)                 |
| 顺序线性结构：入队按照大小顺序排列入队           | O(n)    | O(1)                 |
| 堆                                               | O(logn) | O(logn)              |

### 8-2 堆的基础表示

 堆最为主流的一种实现方式：**二叉堆**

**二叉堆的性质**：

* 二叉堆是一颗完全二叉树
  * 完全二叉树：不一定是满二叉树（除了叶子节点，其他节点的左右子数都不为空），但是缺失的部分一定是在二叉树的右侧。
* 最大堆：二叉堆中某个节点的值总是不大于其父节点的值（根节点的元素是最大的）。
* 最小堆：二叉堆中某个节点的值总是不小于其父节点的值（根节点的元素是最小的）。

注意：最大堆的低层级的节点值不一定就大于高层级的节点值。

![](http://static.zybuluo.com/vermouth9/7v0n32j4m06495y92tmkie0n/image.png)

例如位于2层的16和3层的19。

因为完全二叉树可以看作一层一层地从左向右码上去，所以可以把完全二叉树用数组来存储。

| 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 62   | 41   | 30   | 28   | 16   | 22   | 13   | 19   | 17   | 15   |

此时对于节点 i（节点在数组中的索引是 i）：
$$
parent(i) = (i - 1) / 2
$$

$$
left child = 2 * i + 1
$$

$$
right child = 2 * i + 2
$$

### 8-3 向堆中添加元素和Sift Up

1. 先在index 10添加元素52
2. 因为52的父节点 16小于 52，所以把52和16换一下位置，即把索引4变为52，索引10变为16
3. 此时52依然大于父节点41，所以把52和41再交换位置
4. 此时满足堆的性质。

### 8-4 从堆中取出元素和Sift Down

1. 取出堆的根节点
2. 把堆数组的最后一个元素挪到根节点
3. 把根节点元素和子元素的最大值比较，如果小，则交换位置，依次进行下去，直到满足堆特性。

### 8-5 Heapify和Replace

* Replace：取出堆中最大元素，再向堆中添加一个元素

  可以直接用新添加的元素替换堆顶元素，再执行Sift Down即可

* heapify：将任意数组整理成堆的形状

  把数组看作一个完全二叉树，从最后一个非叶子节点i开始，从索引i到0不断进行Sift Down操作，直到满足堆性质。

**计算最后一个非叶子节点的索引**：直接根据最后一个节点的索引，计算其父节点，也就是最后一个非叶子节点。

* 将n个元素逐个插入到一个空堆中，算法复杂度是O(logn)，因为对每个元素都要执行O(logn)级别的插入操作，总共有n个元素。
* heapify的过程，算法复杂度是O(n)。

```java
public class MaxHeap<E extends Comparable<E>> {

    private List<E> data;

    public MaxHeap(int capacity) {
        data = new ArrayList<>(capacity);
    }

    public MaxHeap() {
        data = new ArrayList<>();
    }

    /**
     * heapify
     * @param arr 任意元素
     */
    public MaxHeap(E[] arr) {
        data = new ArrayList<>(Arrays.asList(arr));
        for (int i = parent(arr.length - 1); i >= 0; i--) {
            siftDown(i);
        }
    }

    public int size() {
        return data.size();
    }

    public boolean isEmpty() {
        return data.isEmpty();
    }

    // 返回完全二叉树的数组表示中，一个索引所表示的元素的父节点的索引
    private int parent(int index) {
        if (index == 0) {
            throw new IllegalArgumentException("index-0木有父节点");
        }
        return (index - 1) / 2;
    }

    // 返回完全二叉树的数组表示中，一个索引所表示的元素的左孩子节点的索引
    private int leftChild(int index) {
        return index * 2 + 1;
    }

    // 返回完全二叉树的数组表示中，一个索引所表示的元素的右孩子节点的索引
    private int rightChild(int index) {
        return index * 2 + 2;
    }

    // 向堆中添加元素
    public void add(E e) {
        data.add(e);
        siftUp(data.size() - 1);
    }

    //查看堆的最大值
    public E findMax() {
        if (data.size() == 0) throw new IllegalArgumentException("堆是空的");
        return data.get(0);
    }

    // 从堆中取出最大元素
    public E extractMax() {
        E result = findMax();
        data.set(0, data.get(data.size() - 1));
        data.remove(data.size() - 1);
        siftDown(0);
        return result;
    }

    // 取出堆中最大元素，并且替换成元素e
    public E replace(E e) {
        E ret = findMax();
        data.set(0, e);
        siftDown(0);
        return ret;
    }

    private void siftDown(int k) {
        while (leftChild(k) < data.size()) {
            int i = leftChild(k);
            if (i + 1 < data.size() && data.get(i + 1).compareTo(data.get(i)) > 0) {
                i = rightChild(k);
            }
            //此时data.get(i)是左右两个子节点的最大值
            if (data.get(i).compareTo(data.get(k)) <= 0)
                break;
            E tmp = data.get(i);
            data.set(i, data.get(k));
            data.set(k, tmp);
            k = i;
        }
    }

    private void siftUp(int index) {
        for (; index > 0 && data.get(parent(index)).compareTo(data.get(index)) < 0;) {
            E tmp = data.get(parent(index));
            data.set(parent(index), data.get(index));
            data.set(index, tmp);
            index = parent(index);
        }
    }
}
```

### 8-7 Leetcode上优先队列相关问题

在1,000,000个元素中选出前100名？

在N个元素中选出前M个元素：

* 排序 ==> O(NlogN)
* 优先队列 ==> O(NlogM)

使用优先队列，维护当前看到的前M个元素，遇见一个新的元素，把它和队列中最小的元素比，如果比最小的大，则把最小的元素替换成当前元素，并执行相应操作满足二叉堆的性质。

这里需要使用***最小堆***。或者使用最大堆，但是规定频率越小优先级越高。

> 注：最大堆和最小堆的大和小都是相对的，可以根据需要定义不同的大和小的概念。

### 8-8 Java中的PriorityQueue

Java中的PriorityQueue内部是最小堆。

### 8-9 和堆相关的更多话题和广义队列

**这里实现的堆有一个明显的缺点**：只能看见堆首的元素，不能看见堆中的元素。

索引堆：可以解决这个问题，还可以修改堆中的元素。

##  C9 线段树

### 9-1 什么是线段树

线段树、区间树、Segment Tree

1. 为什么要使用线段树？

   * 有一类问题，我们关心的是线段（或者区间）

   * 最经典的线段树问题：区间染色

     有一面墙，长度为n，每次选择一段墙进行染色（可以覆盖之前已经染过色的区间），m次操作后，我们可以在[i, j]区间内看见多少种颜色？

     |                      | 使用数组实现 |
     | -------------------- | :----------: |
     | 染色操作（更新区间） |     O(n)     |
     | 查询操作（查询区间） |     O(n)     |

   * 另一类经典问题：区间查询

     查询一个区间[i, j]的最大值，最小值，或者区间数字和

     2017年注册用户中消费最高的用户？消费最小的用户？学习时间最长的用户？数据是动态的，因为用户在不断地进行消费，2017年注册的用户2018年也在接着消费，数据在持续不停地更新的同时进行查询。

     |      | 使用数组实现 | 使用线段树 |
     | ---- | :----------: | :--------: |
     | 更新 |     O(n)     |  O(logn)   |
     | 查询 |     O(n)     |  O(logn)   |

     对于给定区间

     更新：更新区间中一个元素或者一个区间的值

     查询：查询一个区间的最大值，最小值，或者区间数字和

2. 什么是线段树

   ![](http://static.zybuluo.com/vermouth9/j4ovyf1g4ep0osmbucb9hfmw/image.png)

   以求和为例：根节点存储的是整个区间的和，A[0...3]存储的是0-3这个区间的和，A[4...7]存储的是4-7这个区间的和。如果要求3-5这个区间的和，那么只需把A[3]和A[4...5]这两个节点加起来就行。

### 9-2 线段树基础表示

![](http://static.zybuluo.com/vermouth9/0tzdntcdrk3z6mgj8o1u74ge/image.png)

线段树不一定是完全二叉树，线段树是平衡二叉树

***平衡二叉树***：对于整棵树来说，最大的深度和最小的深度相差不能超过1。

完全二叉树一定是平衡二叉树，所以堆也是平衡二叉树。

二分搜索树不一定是平衡二叉树。

线段树也可以用数组来表示，可以把它看作是完全二叉树，缺失的部分都是null。

**如果区间有n个元素，数组表示需要有多少个节点？**

对满二叉树：h层，一共有2^h - 1个节点（约2 ^ h），最后一层（h-1层），有2 ^ (h-1)个节点，所以最后一层地节点数大致等于前面所有层节点之和。

如果区间有n个元素：

![](http://static.zybuluo.com/vermouth9/glpxjkcc44p37l20scdcyxys/image.png)

我们的线段树不考虑添加元素，即区间固定，使用4n的静态空间即可。

例如区间里有5个元素：

![](http://static.zybuluo.com/vermouth9/kjlxn4da6ei5bz9cfavb0xwf/image.png)

```java
public class SegmentTree<E> {
    private E[] tree;
    private E[] data;
    private Merger<E> merger;

    public SegmentTree(E[] arr, Merger<E> merger) {
        data = (E[])new Object[arr.length];
        for (int i = 0; i < arr.length; i++) {
            data[i] = arr[i];
        }
        this.merger = merger;
        tree = (E[])new Object[arr.length * 4];
        buildSegmentTree(0, 0, data.length - 1);
    }

    /**
     * 在treeIndex的位置创建表示区间[l...r]的线段树
     * @param treeIndex 当前索引
     * @param s 区间起始位置
     * @param e 区间结束位置
     */
    private void buildSegmentTree(int treeIndex, int s, int e) {
        if (s == e) {
            tree[treeIndex] = data[s];
            return;
        }
        int leftTreeIndex = leftChild(treeIndex);
        int rightTreeIndex = rightChild(treeIndex);
        int mid = s + (e - s) / 2;          // 防止s + e太大溢出
        buildSegmentTree(leftTreeIndex, s, mid);
        buildSegmentTree(rightTreeIndex, mid + 1, e);

        tree[treeIndex] = merger.merge(tree[leftTreeIndex], tree[rightTreeIndex]);           // 这个是和业务逻辑相关的
    }

    public int getSize() {
        return data.length;
    }

    public E get(int index) {
        if (index < 0 || index >= data.length)
            throw new IllegalArgumentException("索引不合法");
        return data[index];
    }

    // 返回一个完全二叉树的数组表示中，一个索引所表示的元素的左孩子节点的索引
    private int leftChild(int index) {
        return index * 2 + 1;
    }

    // 返回一个完全二叉树的数组表示中，一个索引所表示的元素的右孩子节点的索引
    private int rightChild(int index) {
        return index * 2 + 2;
    }

    /**
     * 线段树的查询，返回区间[start, end]的值
     * @param queryS 起始索引
     * @param queryE 结束索引
     * @return 区间[start, end]的值
     */
    public E query(int queryS, int queryE) {
        if (queryS < 0 || queryE < 0 || queryS > data.length || queryE > data.length || queryS > queryE)
            throw new IllegalArgumentException("参数不合法");
        return query(0, queryS, queryE, 0, data.length - 1);
    }

    /**
     * 把data的dataIndex位置的值更新为e
     * @param dataIndex
     * @param e
     */
    public void set(int dataIndex, E e) {
        if (dataIndex < 0 || dataIndex > data.length)
            throw new IllegalArgumentException("参数不合法");
        data[dataIndex] = e;
        set(0, 0, data.length - 1, dataIndex, e);
    }

    private void set(int treeIndex, int start, int end, int dataIndex, E e) {
        if (start == end) {
            tree[treeIndex] = e;
            return;
        }
        int leftChild = leftChild(treeIndex);
        int rightChild = rightChild(treeIndex);
        int mid = start + (end - start) / 2;
        if (dataIndex >= mid + 1)
            set(rightChild, mid + 1, end, dataIndex, e);            //更新右子树
        else
            set(leftChild, start, mid, dataIndex, e);                    //更新左子树
        tree[treeIndex] = merger.merge(tree[leftChild], tree[rightChild]);      //根据右子树和左子树来更新当前节点
    }


    private E query(int treeIndex, int queryS, int queryE, int start, int end) {
        if (queryS == start && queryE == end)
            return tree[treeIndex];
        int mid = start + (end - start) / 2;
        int leftTreeIndex = leftChild(treeIndex);
        int rightTreeIndex = rightChild(treeIndex);
        if (queryS >= mid + 1) {
            return query(rightTreeIndex, queryS, queryE, mid + 1, end);
        }else if (queryE <= mid) {
            return query(leftTreeIndex, queryS, queryE, start, mid);
        }else {
            E leftResult = query(leftTreeIndex, queryS, mid, start, mid);
            E rightResult = query(rightTreeIndex, mid + 1, queryE, mid + 1, end);
            return merger.merge(leftResult, rightResult);
        }
    }

    @Override
    public String toString() {
        StringBuilder res = new StringBuilder();
        res.append('[');
        for (int i = 0; i < tree.length; i++) {
            if (tree[i] != null)
                res.append(tree[i]);
            else
                res.append("null");
            if (i != tree.length - 1)
                res.append(", ");
        }
        res.append(']');
        return res.toString();
    }
}


interface Merger<E> {
    E merge(E a, E b);
}
```

### 9-7 更多线段树相关的话题

将区间中所有元素更新：O(n)的复杂度，为了解决这个问题，可以用懒惰更新。

对于区间操作还有一个重要的数据结构：树状数组（Binary Index Tree）

## C10 Trie 字典树

1. 什么是字典树（前缀树，Trie）

   Trie只用来处理字符串

   | 字典                                                         | Trie                                                         |
   | ------------------------------------------------------------ | ------------------------------------------------------------ |
   | 如果有n个条目，使用树结构，查询的时间复杂度是O(logn)，如果有100万个条目（2^20），logn大约为20 | 查询每个条目的时间复杂度和字典中一共有多少条目无关，时间复杂度为O(w)，w为查询单词的长度 |

   ![](http://static.zybuluo.com/vermouth9/u4yewg9lqsqyqyjwgbo8k1nw/image.png)

   上图中每一条都是一个单词，如图所示，查找一个单词只和单词的长度相关。

   每个节点有若干个指向下个节点的指针。

   ```java
   class Node {
       boolean isWord;    
       Map<Character, Node> next;
   }
   ```

 ```java
public class Trie {

    private class Node {
        public boolean isWord;			//当前节点是否是一个单词的结尾
        public TreeMap<Character, Node> next;
        public Node(boolean isWord) {
            this.isWord = isWord;		
            next = new TreeMap<>();
        }
        public Node() {
            this(false);
        }
    }

    private Node root;
    private int size;   //存储了多少单词

    public Trie() {
        root = new Node();
        size = 0;
    }

    //获得Trie中存储的单词数量
    public int getSize() {
        return size;
    }

    public void add(String word) {
        Node cur = root;
        for (int i = 0; i < word.length(); i++) {
            char c = word.charAt(i);
            if (cur.next.get(c) == null) {
                cur.next.put(c, new Node());
            }
            cur = cur.next.get(c);
        }
        if (!cur.isWord) {
            cur.isWord = true;
            size++;
        }
    }

    /**
     * 查询单词word是否在Trie中
     * @param word 要查询的单词
     * @return 单词是否在Trie中
     */
    public boolean contains(String word) {
        Node cur = root;
        for (int i = 0; i < word.length(); i++) {
            char c = word.charAt(i);
            if (cur.next.get(c) == null) {
                return false;
            }
            cur = cur.next.get(c);
        }
        return cur.isWord;
    }

    /**
     * 查询是否有以prefix为前缀的单词
     * @param prefix 前缀
     * @return
     */
    public boolean startWith(String prefix) {
        Node cur = root;
        for (int i = 0; i < prefix.length(); i++) {
            char c = prefix.charAt(i);
            if (cur.next.get(c) == null) {
                return false;
            }
            cur = cur.next.get(c);
        }
        return true;
    }
}
 ```

### 10-7 更多和Trie字典树相关的话题

Trie最大的问题：空间

## C11 并查集

一种由孩子指向父亲的树结构，可以解答图中的两点之间是否连同，非常快得判断网络中节点间的连接状态。也是数学中的集合类的实现。

对于一组数据，主要支持两个动作：

* union(p, q)
* isConnected(p, q)

### 11-2 Quick Find

| 节点编号       | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    |
| -------------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 所属的集合编号 | 0    | 1    | 0    | 1    | 0    | 1    | 0    | 1    | 0    | 1    |

10个数据分为了两个集合，0和2属于同一个集合，所以它们之间是相连接的，0和1之间不连接。把这个步骤抽象一下，就是对于节点p和节点q，看看```find(p) == find(q)```是否成立，如果成立，则p和q是连接的。

Quick Find：

* union(p, q) ==> O(n)
* isConnected(p, q) ==> O(1)

```java
public class UnionFind1 implements UF {

    private int[] id;

    public UnionFind1(int size) {
        id = new int[size];
        for (int i = 0; i < size; i++)
            id[i] = i;          //初始时所有节点之间互不相连，每个元素属于不同集合
    }

    @Override
    public int getSize() { return id.length; }

    /**
     * 查找元素p对应的集合编号
     * @param p 节点
     * @return p所属的集合
     */
    private int find(int p) {
        if (p < 0 || p >= id.length)
            throw new IllegalArgumentException("参数不合法");
        return id[p];
    }

    /**
     * 查看元素p和元素q是否属于一个集合
     * @param p
     * @param q
     * @return
     */
    @Override
    public boolean isConnected(int p, int q) {
        return find(p) == find(q);
    }

    /**
     * 合并元素p和元素q所属的集合
     * @param p 元素p
     * @param q 元素q
     */
    @Override
    public void unioncElement(int p, int q) {
        int commP = find(p);
        int commQ = find(q);
        if (commP == commQ) return;
        for (int i = 0; i < id.length; i++) {
            if (find(i) == commQ)
                id[i] = commP;
        }
    }
}
```

### 11-3 Quick Union

将每一个元素，看做是一个节点

![](C:\Users\Administrator\AppData\Local\Temp\1530771547382.png)

如果所示，5、6、7属于一个集合，1、2、3属于一个集合，如果要合并3和7所属的集合，只需将7所在的树的根节点，也就是5指向2即可。

![](http://static.zybuluo.com/vermouth9/zr52siivl9vfw4gwvwg5sd3s/image.png)

Quick Unionc：

* union(p, q) ==> O(h)
* isConnected(p, q) ==> O(h)

h是树的高度

所以还可以用数组来存储，只不过数组中存储的是第i个元素所在的节点指向了哪个元素，所以在初始的时候，每个元素都指向自己。

```java
public class UnionFind2 implements UF {

    private int[] parent;

    public UnionFind2(int size) {
        parent = new int[size];
        for (int i = 0; i < size; i++)
            parent[i] = i;          //初始的时候每个节点都指向自己，每个节点都是一颗独立的树
    }

    @Override
    public int getSize() {
        return parent.length;
    }

    private int find(int p) {
        if (p < 0 || p >= parent.length)
            throw new IllegalArgumentException("参数不合法");
        while (parent[p] != p) {
            p = parent[p];
        }
        return parent[p];
    }

    @Override
    public boolean isConnected(int p, int q) {
        return find(p) == find(q);
    }

    @Override
    public void unioncElement(int p, int q) {
        int pRoot = find(p);
        int qRoot = find(q);
        if (pRoot == qRoot) return;
        parent[pRoot] = qRoot;
    }
}
```

这个实现有一个问题，在极端情况下很有可能形成一个单链表，导致树的深度很大。

**优化方式**：

1. 基于size的优化

   ```java
   public class UnionFind3 implements UF {
       private int[] parent;
       private int[] sz;           //sz[i]表示以i为根的集合中元素个数
   
       public UnionFind3(int size) {
           parent = new int[size];
           sz = new int[size];
           for (int i = 0; i < size; i++) {
               parent[i] = i;          //初始的时候每个节点都指向自己，每个节点都是一颗独立的树
               sz[i] = 1;
           }
       }
       
       // 其他操作和UnionFind2一样
   
       @Override
       public void unioncElement(int p, int q) {
           int pRoot = find(p);
           int qRoot = find(q);
           if (pRoot == qRoot) return;
           if (sz[pRoot] < sz[qRoot]) {
               parent[pRoot] = qRoot;
               sz[qRoot] += sz[pRoot];
           }else {
               parent[qRoot] = pRoot;
               sz[pRoot] += sz[qRoot];
           }
       }
   }
   ```

2. 基于rank的优化

   rank就是指树的高度

   ![](http://static.zybuluo.com/vermouth9/u44nstsbmkyytoex4q1fb7m2/image.png)

   所以更加合理的方式是在每个节点上记录一下以这个节点为根的这棵树的最大深度，在合并时应该是深度比较浅的树指向深度比较深的树。

   ```java
   public class UnionFind4 implements UF {
       private int[] parent;
       private int[] rank;           //sz[i]表示以i为根的树的深度
   
       public UnionFind4(int size) {
           parent = new int[size];
           rank = new int[size];
           for (int i = 0; i < size; i++) {
               parent[i] = i;          //初始的时候每个节点都指向自己，每个节点都是一颗独立的树
               rank[i] = 1;
           }
       }
   
       // 其他操作和UnionFind2一样
   
       @Override
       public void unioncElement(int p, int q) {
           int pRoot = find(p);
           int qRoot = find(q);
           if (pRoot == qRoot) return;
           if (rank[pRoot] < rank[qRoot])
               parent[pRoot] = qRoot;
           else if (rank[qRoot] < rank[pRoot])
               parent[qRoot] = pRoot;
           else {
               parent[qRoot] = pRoot;
               rank[pRoot] += 1;
           }
       }
   }
   ```

3. 路径压缩

   ![](http://static.zybuluo.com/vermouth9/jj7nrecp4z8xwtrsioo8crrc/image.png)

   路径压缩可以把一颗比较高的树压缩成比较矮的树。

   路径压缩发生在```find()```中：```parent(p) = parent[parent[p]]```

   ```java
   public class UnionFind5 implements UF {
       private int[] parent;
       private int[] rank;           //sz[i]表示以i为根的树的深度
   
       //其他的和UnionFInd4一样
   
       private int find(int p) {
           if (p < 0 || p >= parent.length)
               throw new IllegalArgumentException("参数不合法");
           while (parent[p] != p) {
               parent[p] = parent[parent[p]];          //把当前节点指向父亲的父亲节点
               p = parent[p];
           }
           return parent[p];
       }
   }
   ```

   这个路径压缩只能相对减少树的高度，最理想的情况应该是所有树的高度就只有2，可以通过递归来实现

   ```java
   public class UnionFind6 implements UF {
       private int[] parent;
       private int[] rank;           //sz[i]表示以i为根的树的深度
   
       /**
        * 得到current这个节点的根节点，并把所有子节点全都直接指向根节点
        * @param p
        * @return p节点的根节点
        */
       private int find(int p) {
           if (p < 0 || p >= parent.length)
               throw new IllegalArgumentException("参数不合法");
           if (parent[p] != p)
               parent[p] = find(parent[p]);
           return parent[p];
       }
   }
   ```

   但实际上，UnionFind6的速度没有UnionFind5快，因为递归有时间开销。

   并查集的时间复杂度：```O(log*n)```
   $$
   log*n = \begin{cases} 0, & \text {if $n$ $\leq$ 1} \\ 1 + log*(logn), & \text{if $n$ > 1} \end{cases}
   $$
   比```O(logn)```还快，近乎于```O(1)```。

## C12 AVL

二分搜索树的问题：如果是按从小到大或者从大到小的顺序添加二分搜索树的话，二分搜索树会退化为单链表。

 AVL：最经典的平衡二叉树，最早的自平衡二分搜索树。

一棵满二叉树和完全二叉树一定是平衡二叉树。

* 平衡二叉树：二叉树中，对于任意一个叶子节点，高度差不能超过1。
* AVL中的平衡二叉树：对于任意一个节点，左子树和右子树的高度差不能超过1。

![](C:\Users\Administrator\AppData\Local\Temp\1530777813519.png)

如图，这个满足AVL中的平衡二叉树，但这种结构不会出现在堆或者线段树中。这种平衡二叉树的高度和节点数量之间的关系也是```O(logn)```的。

AVL树既是二分搜索树，也是平衡二叉树。

### 12-4 旋转操作的基本原理

AVL树的左旋转和右旋转。

插入一个节点才有可能破坏平衡性，所以维护平衡的时机，**应该是加入节点后，沿着节点向上维护平衡性**。













